# -*- coding: utf-8 -*-
"""XML_to_BN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b__Jhj9q5gsMMwv3ee3BezYYzktqWlri
"""

import xml.etree.ElementTree as ET
import random

class bayesian_network:

  def __init__(self , name):
    self.name = name
    self.children = []
    self.parent = []
    self.probs = None
    self.value = 0

  def __repr__(self):
    one = ("Variable Name : {}\n".format(self.name))
    two = ("Number of children : {}\n".format(len(self.children)))
    three = ("Number of parents : {}\n".format(len(self.parent)))
    four = ("Value : {}\n".format(self.value))
    return one + two + three + four

  def flip(self , p):
    if random.random() < p :
      self.value = 1
    else:
      self.value = 0

def make_nodes(xml_node):

  l1 = []
  var_nodes = []
  for i in xml_node.iter('VARIABLE'):
    l1.append(i)
  for var in l1:
    if var[0].tag == 'NAME':
      var_nodes.append(bayesian_network(var[0].text))
    else:
      print("Bro , your XML file is not in the format Jeet would approve of ~")
  
  return var_nodes

def find_corresponding_node(var_nodes , name):
  for i in var_nodes:
    if i.name == name:
      break
  return i

def space_parser(text):

  l1 = []
  j = 0
  for i in range(len(text)):
    if text[i] == " ":
      l1.append(float(text[j:i]))
      j = i+1
  l1.append(float(text[j:]))
  return l1

def make_network(xml_node , var_nodes , root_node):

  l1 = []
  for i in xml_node.iter('DEFINITION'):
    l1.append(i)
  for i in l1:
    if not ((i[0].tag == 'FOR') and (i[len(i) - 1].tag == 'TABLE')):
      print("Bro , your XML file is not in the format Jeet would approve of ~")
    else:
      if len(i) == 2:
        t = find_corresponding_node(var_nodes , i[0].text)
        t.parent.append(root_node)
        root_node.children.append(t)
        t.probs = space_parser(i[1].text)
      else:
        t = find_corresponding_node(var_nodes , i[0].text)
        for kk in range(1,len(i) - 1):
          t1 = find_corresponding_node(var_nodes , i[kk].text)
          t1.children.append(t)
          t.parent.append(t1)
        t.probs = space_parser(i[len(i) - 1].text)
  return [root_node] + var_nodes


start = bayesian_network('root')
tree = ET.parse('aima-alarm.xml')
root = tree.getroot()
test = make_nodes(root)
y = make_network(root , test , start)